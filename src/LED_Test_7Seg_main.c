//=========================================================
// src/LED_Test_7Seg_main.c: generated by Hardware Configurator
//
// This file will be updated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8SB1_Register_Enums.h>                  // SFR declarations
#include "InitDevice.h"
// $[Generated Includes]
#include "cslib_config.h"
#include "cslib.h"
// [Generated Includes]$

//Defines by Peter//
#define touchCounter	65// works well enough just not too sensitive 75

//Function Prototypes//
void number1(void);
void number2(void);
void number3(void);
void number4(void);
void number5(void);
void number6(void);
void number7(void);
void number8(void);
void number9(void);
void number0(void);
void numberDisplay(uint8_t countIndex);
void leftLED(void);
void rightLED(void);

//Global Variables by Peter//
bool displayToggle = 0;
bool displayChangeValid = 0;

//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
// This function is called immediately after reset, before the initialization
// code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
// useful place to disable the watchdog timer, which is enable by default
// and may trigger before main() in some instances.
//-----------------------------------------------------------------------------
void SiLabs_Startup(void) {

// $[SiLabs Startup]
	/*
	 // WDTE (Watchdog Timer Enable) = DISABLED (Disable Watchdog Timer.)
	 */
	PCA0MD &= ~PCA0MD_WDTE__BMASK;

// [SiLabs Startup]$
}

//Pin Definitions//
SI_SBIT(LEDA, SFR_P0, 1);
SI_SBIT(LEDB, SFR_P0, 2);
SI_SBIT(LEDC, SFR_P0, 3);
SI_SBIT(LEDD, SFR_P0, 4);
SI_SBIT(LEDE, SFR_P0, 5);
SI_SBIT(LEDF, SFR_P0, 6);
SI_SBIT(LEDG, SFR_P0, 7);

SI_SBIT(LED0, SFR_P1, 1);

SI_SBIT(LEDR, SFR_P1, 2);
SI_SBIT(LEDL, SFR_P0, 0);

//-----------------------------------------------------------------------------
// main() Routine
// ----------------------------------------------------------------------------
int main(void) {
	int16_t numberCount = 0;
	uint16_t pressCount = 0;
	bool pressValid = 0;

	// Call hardware initialization routine
	enter_DefaultMode_from_RESET();

	/*PCA0CPH0 = 0x02;
	 PCA0CPH1 = 0x50;*/

	while (1) {
// $[Generated Run-time code]
		// -----------------------------------------------------------------------------
		// If low power features are enabled, this will either put the device into a low
		// power state until it is time to take another scan, or put the device into a
		// low-power sleep mode if no touches are active
		// -----------------------------------------------------------------------------
		CSLIB_lowPowerUpdate();

		// -----------------------------------------------------------------------------
		// Performs all scanning and data structure updates
		// -----------------------------------------------------------------------------
		CSLIB_update();

// [Generated Run-time code]$

		/*if (CSLIB_isSensorDebounceActive(0) && pressValid == 0) {
		 numberCount++;

		 if (numberCount > 9) {
		 numberCount = 9;
		 }

		 LED0 = 1;
		 pressValid = 1;
		 pressCount = 0;
		 } else if (CSLIB_isSensorDebounceActive(1) && pressValid == 0) {
		 numberCount--;

		 if (numberCount < 0) {
		 numberCount = 0;
		 }

		 LED0 = 1;
		 pressValid = 1;
		 pressCount = 0;
		 } else {
		 LED0 = 0;
		 pressCount++;

		 if (pressCount > touchCounter) {
		 pressCount = 0;
		 pressValid = 0;
		 }
		 }*/
		numberCount = 9;
		numberDisplay(numberCount);

	}
}

void number1(void) {
	LEDA = 0;
	LEDB = 1;
	LEDC = 1;
	LEDD = 0;
	LEDE = 0;
	LEDF = 0;
	LEDG = 0;
}

void number2(void) {
	LEDA = 1;
	LEDB = 1;
	LEDC = 0;
	LEDD = 1;
	LEDE = 1;
	LEDF = 0;
	LEDG = 1;
}

void number3(void) {
	LEDA = 1;
	LEDB = 1;
	LEDC = 1;
	LEDD = 1;
	LEDE = 0;
	LEDF = 0;
	LEDG = 1;
}

void number4(void) {
	LEDA = 0;
	LEDB = 1;
	LEDC = 1;
	LEDD = 0;
	LEDE = 0;
	LEDF = 1;
	LEDG = 1;
}

void number5(void) {
	LEDA = 1;
	LEDB = 0;
	LEDC = 1;
	LEDD = 1;
	LEDE = 0;
	LEDF = 1;
	LEDG = 1;
}

void number6(void) {
	LEDA = 1;
	LEDB = 0;
	LEDC = 1;
	LEDD = 1;
	LEDE = 1;
	LEDF = 1;
	LEDG = 1;
}

void number7(void) {
	LEDA = 1;
	LEDB = 1;
	LEDC = 1;
	LEDD = 0;
	LEDE = 0;
	LEDF = 0;
	LEDG = 0;
}

void number8(void) {
	LEDA = 1;
	LEDB = 1;
	LEDC = 1;
	LEDD = 1;
	LEDE = 1;
	LEDF = 1;
	LEDG = 1;
}

void number9(void) {
	LEDA = 1;
	LEDB = 1;
	LEDC = 1;
	LEDD = 1;
	LEDE = 0;
	LEDF = 1;
	LEDG = 1;
}

void number0(void) {
	LEDA = 1;
	LEDB = 1;
	LEDC = 1;
	LEDD = 1;
	LEDE = 1;
	LEDF = 1;
	LEDG = 0;
}

void leftLED(void) {
	LEDR = 0;
	LEDL = 1;
	/*PCA0CPH0 = 0x00;
	 PCA0CPH1 = 0xFF;*/
}

void rightLED(void) {
	LEDR = 1;
	LEDL = 0;
	/*PCA0CPH0 = 0xFF;
	 PCA0CPH1 = 0x00;*/
}

void numberDisplay(uint8_t countIndex) {
	switch (countIndex) {
	case 1:
		if (displayToggle == 1) {
			number0();
			leftLED();
			displayChangeValid = 0;
		} else if (displayToggle == 0) {
			number1();
			rightLED();
			displayChangeValid = 0;
		}
		break;
	case 2:
		if (displayToggle == 1) {
			number0();
			leftLED();
			displayChangeValid = 0;
		} else if (displayToggle == 0) {
			number2();
			rightLED();
			displayChangeValid = 0;
		}
		break;
	case 3:
		if (displayToggle == 1) {
			number0();
			leftLED();
			displayChangeValid = 0;
		} else if (displayToggle == 0) {
			number3();
			rightLED();
			displayChangeValid = 0;
		}
		break;
	case 4:
		if (displayToggle == 1) {
			number0();
			leftLED();
			displayChangeValid = 0;
		} else if (displayToggle == 0) {
			number4();
			rightLED();
			displayChangeValid = 0;
		}
		break;
	case 5:
		if (displayToggle == 1) {
			number0();
			leftLED();
			displayChangeValid = 0;
		} else if (displayToggle == 0) {
			number5();
			rightLED();
			displayChangeValid = 0;
		}
		break;
	case 6:
		if (displayToggle == 1) {
			number0();
			leftLED();
			displayChangeValid = 0;
		} else if (displayToggle == 0) {
			number6();
			rightLED();
			displayChangeValid = 0;
		}
		break;
	case 7:
		if (displayToggle == 1) {
			number0();
			leftLED();
			displayChangeValid = 0;
		} else if (displayToggle == 0) {
			number7();
			rightLED();
			displayChangeValid = 0;
		}
		break;
	case 8:
		if (displayToggle == 1) {
			number0();
			leftLED();
			displayChangeValid = 0;
		} else if (displayToggle == 0) {
			number8();
			rightLED();
			displayChangeValid = 0;
		}
		break;
	case 9:
		if (displayToggle == 1) {
			number0();
			leftLED();
			displayChangeValid = 0;
		} else if (displayToggle == 0) {
			number9();
			rightLED();
			displayChangeValid = 0;
		}
		break;
	default:
		if (displayToggle == 1) {
			number0();
			leftLED();
			displayChangeValid = 0;
		} else if (displayToggle == 0) {
			number0();
			rightLED();
			displayChangeValid = 0;
		}
	}
}
